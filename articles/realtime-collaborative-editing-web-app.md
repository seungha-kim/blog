# 2021-07 실시간 동시편집 웹 어플리케이션 PoC - 아키텍처

요약 - Figma 블로그 내용을 바탕으로, 단일리더 분산 시스템에 기반한 간단한 실시간 동시편집 웹 어플리케이션을 만들어 본 경험을 소개한다.

이 문서에서 사용하는 실시간 이라는 용어는 일반적으로 준-실시간으로 일컬어지는 정도의 수준을 뜻하며, 수 초 정도의 지연은 장애가 아닌 것으로 본다.

## 실시간 동시편집 웹 어플리케이션의 요구사항

- (필수) 여러 사용자가 네트워크로 상호간 연결된 상태에서 하나의 문서를 편집한다
- (필수) 모든 사용자는 결국에 같은 문서 상태로 수렴해야 한다. (eventual consistency)
- (필수) 다른 사용자가 편집한 내용을 실시간으로 확인할 수 있다
- (필수) 내가 편집한 내용을 되돌릴 수 있다. (undo, redo)
- (필수) 잠깐 동안 네트워크에 문제가 생기더라도, 문제없이 편집을 이어나갈 수 있다.
- (선택) 서로 독립적으로 편집된 두 문서를 병합할 수 있다.
- (선택) 서버에 접속하지 않고도 편집을 할 수 있다. (오프라인 편집)
- (선택) 다른 사용자가 어떤 행동을 하고 있는지 실시간으로 확인할 수 있다.

## 해결해야 하는 문제

- 편집 시점의 차이 때문에, 혹은 서로 독립적으로 편집되었기 때문에 두 클라이언트의 편집 내용 간 충돌이 발생할 수 있다.

## Figma에서 공개한 내용

일반적으로는 CRDT가 회자된다. 하지만 Figma 는 CRDT를 사용하지 않음

`TODO`
- Figma 글 요약
	- CRDT 까지 필요하지 않다. CRDT는 복잡... 이런 방식은 구현이 간단해서

단일 리더 분산 시스템 - 실제로 이런 제약사항 때문에 Figma 서버에 문제가 생기면 아예 편집기를 쓸 수 없는 상황이 발생하기도 한다.

`TODO` 회사 Slack 에서 찾아보기

충돌 처리

- 기본적으로 트리 형태의 문서를 다루는 것이다.
- 위치 변경 등 다른 노드에 영향을 prop 변경은 쉽다 - LWW
- 순서가 바뀌거나, 계층구조가 바뀌는 경우, 삭제되는 경우가 어렵다.
- fractional index - 그냥 IEEE-754 부동소수점을 쓰면 문제가 어렵다. (base95)
- tree validation (cycle이 생기지 않았는지)

### Undo/redo 어떻게 하는 것인가

Undo 란 무엇인가?

    내가, 이전에 했던 작업을, 원래대로 되돌려놓는 작업
    작업 : 생성, 수정, 삭제, ...
    여러 번 할 수 있음 - stack
    작업을 하면, 해당 작업에 대한 undo transaction 을 스택에 쌓는다.
    undo를 하면, undo stack 에서 pop을 해서 해당 트랜잭션을 커밋하고, 해당 undo를 되돌리는 트랜잭션을 만들어서 redo stack에 넣는다.

Redo 란 무엇인가?

    내가, 방금 전에 Undo 했던 작업을, 원래대로 되돌려놓는 작업
    여러 번 할 수 있음 - stack
    redo를 하다가 조금이라도 편집을 하게 되면, redo를 할 수 없음. 즉 redo 스택이 비워짐.

### 순서값 관련 어려움 (일단 복붙)

f32는 0 상하로 100개 정도 (총 200개 정도)
f64는 0 상하로 1000개 정도 (총 2000개 정도)
https://en.wikipedia.org/wiki/IEEE_754

순서값 결정

    첫 번째: 0
    앞에 삽입: -1과 평균: -0.5
    뒤에 삽입: 1과 평균: 0.5

그러니까 맨 앞에 넣을 때는 이전의 맨 앞 객체의 순서값과 -1의 평균을 구해서 넣는다.

순서 바꾸기 => 삽입
트리의 같은 레벨에서 순서를 2000번 넘게 바꿨다 => 으음...

순서값 normalize는 필요하겠다 (-1~1 사이에 균등하게 배치)
normalize 할 타이밍이 애매하지만 어떻게든 만들긴 해야겠지... 어차피 tombstone 처리 등등 주기적으로 정리해야할 일은 생길듯

-> normalize 과정이 따로 필요하고, normalize 하기 전에는 충돌이 날 가능성이 생겨버린다.

### 삭제 어려움 (일단 복붙)

삭제의 undo 가 제대로 되지 않음 -> kvs 수준에서는 되는데, UI에서 보이지 않음 -> invalidated_object_id 에서 parent 가 나와야 하는데 나오지 않음

두 가지 해결책

-> 일단 DeleteObject undo (CreateObject) 에 대해서 parent 를 invalidated_object_ids 에 나오도록 한다. -> 이건 CreateObject 에 parent 정보가 없어서 힘들겟네 XXX

-> DeleteObject 할 때 해당 object의 모든 prop 까지 지운다 -> 그러면 parent prop 이 원상복구 되면서 invalidated object ids 에 들어갈 것. -> 이게 궁극적인 해결책인데, '해당 object의 모든 prop' 을 가져오는걸 만들기가 좀 귀찮다...

이런거 하려면 아랫단 저장소 구조가 좀 정리되어야 할 것 같다

(Update) tombstone 아예 없애버리고 두 번째 방식으로 했음


## 기술 스택

- Rust, WASM
- 드로잉은 간단히 하기 위해서 SVG 선택 - 2D canvas api를 사용하거나 CanvanKit 같은 것 사용할 수 있을 것
- Preact - React가 익숙한데 SVG 그대로 쓸 수 있기 때문에 선택

## 아키텍처 설계

- 아키텍처 오버뷰 `TODO`그림 그리기

### 인메모리 키벨류 데이터베이스

- 간단한 트랜잭션 키-밸류 인 메모리 데이터베이스 - 트랜잭션 레이어링 아이디어 `TODO`그림 그리기
- invalidation `TODO`그림 그리기

## 아직 답을 찾지 못한 문제들

- validation nack 어떻게 할 것인가
- undo 하다가 validation error가 난다면? 일부만 적용할 것인가? undo stack을 날려버릴 것인가?
- 다른 사람의 comitted tx가 내 dirty tx와 충돌나면 어떻게 하지? (이게 피그마의 트리 validtion)
- 삭제, tombstone? 쓰레기 정리?

## 남겨진 과제

- high availability
- persistence - 분산 트랜잭션을 지원하는 분산 데이터베이스... MongoDB 를 사용하면 되지 않을까?

## 참고 자료

- Figma 글
- Designing Data-Intensive Applications
